<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="None">
  
  
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>eblog</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u6587\u6863";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> eblog</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href=".">文档</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">学习记录</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#unit-test">Unit Test</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#controller">Controller</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#service">Service</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dao">DAO</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reference">Reference</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#git">Git</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#docker">Docker</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#k8s">K8S</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">问题记录</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cicd">CI/CD</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#dinddocker-in-docker">DIND（docker in docker）</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">其他</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#mybatis-plus-in-condition">mybatis-plus in condition</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#spring-resttemplateurlencode">Spring-RestTemplate之urlencode参数解析异常</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#spring-logback-additivity">Spring-logback additivity</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">eblog</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>文档</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="_1">文档</h1>
<p>学习工作记录文档，包括学习总结和工作中遇到的问题记录。</p>
<h2 id="_2">学习记录</h2>
<h3 id="unit-test">Unit Test</h3>
<p>最近学习了一些Java Unit Test方面的知识，空闲之余归纳总结一下，加深记忆。</p>
<p>现在主流的开发一般都是基于SpringBoot框架开发的，结构大多数是Controller + Service + DAO，Controller一般是数据展示层，Service是业务逻辑层，DAO一般是数据持久层，持久层会使用ORM框架开发。因此我们的单元测试是基于这三层进行的，ORM框架选择的是Mybatis-Plus，测试框架使用的Spring自带的Junit4和Junit5。</p>
<p>测试用到的一些测试工具：</p>
<pre><code class="language-java">    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'      
        testImplementation 'junit:junit:4.13.1'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testImplementation 'com.h2database:h2:2.1.210'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0' // Junit5 engine
    testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.7.0' // Junit4 engine
    testCompileOnly 'org.mockito:mockito-junit-jupiter:2.19.0'
    testCompileOnly 'org.mockito:mockito-core:2.19.0'
    testImplementation &quot;org.testcontainers:mysql:1.16.3&quot;
    testImplementation &quot;org.testcontainers:junit-jupiter:1.16.3&quot;
</code></pre>
<h4 id="controller">Controller</h4>
<p>Controller中使用到的关键注解和类有：</p>
<ul>
<li>@WebMvcTest</li>
<li>@MockBean</li>
<li>@BeforeEach</li>
<li>MockMvc</li>
</ul>
<p>@WebMvcTest 是用于只关注Spring MVC组件的Spring MVC测试的注释， 使用此注释将禁用完全自动配置，而只应用于与MVC测试相关的配置，不能应用于@Component、@Service或@Repository 这些bean。一般该注解位于测试类上面的。如果想加载完整的应用程序配置并使用MockMVC，那么应该考虑结合@SpringBootTest和@AutoConfigureMockMvc来代替这个注释，这种情况多用于集成测试。</p>
<pre><code class="language-java">/**
 * TraceBatchesController uint test.
 */
@WebMvcTest(TraceBatchesController.class)
class TraceBatchesControllerTest {
}
</code></pre>
<h4 id="service">Service</h4>
<p>Service层的测试用到了一些测试工具，分别有：</p>
<ul>
<li>Mockito</li>
<li>spring-boot-starter-test</li>
</ul>
<p>Mockito主要是用来做存根的，当方法中需要调用其他对象的引用，如果不想真实的去调用可以使用Mockito去模拟调用返回想要的结果。Mockito中有许多定义的注解，可以很方便的去模拟不同的对象，其中最常用的就是@InjectMocks、@Mock和@Spy注解。</p>
<blockquote>
<p>@InjectMocks</p>
</blockquote>
<p>该注解标记的字段表明该对象是一个可以注入依赖的对象，通常会将标记了@Mack的字段注入到该对象中，所以@InjectMocks注解通常会和@Mock注解结合使用。<strong>注：这些注解标注的字段此时还未初始化，可以手动初始化也可以使用注解@ExtendWith(MockitoExtension.class)自动初始化，Junit5使用的@ExtendWith(MockitoExtension.class)，Junit4使用的是 @RunWith(MockitoJUnitRunner.class)</strong></p>
<blockquote>
<p>@Mock</p>
</blockquote>
<p>该注解是用来模拟真实的对象的，模拟后可使用when...thenReturn...的方式模拟对象方法的调用，真实的逻辑在调用该方法时会返回模拟对应的返回值，从而达到真实逻辑运行的效果。@Mock注解通常会和@InjectMocks注解结合使用。</p>
<blockquote>
<p>@Spy</p>
</blockquote>
<p>该注解是用来实现模拟对象的部分真实逻辑的，当你真实的创建一个类的对象后，想测试该类的A方法时，发现方法内部又调用了该类的B方法，此时你不想真正的去走B方法希望可以模拟B方法，这时你就可以使用@Spy去实现该场景。</p>
<p>Service层逻辑</p>
<p>​   主要是创建traceBatches这个类，然后将traceBatches保存到数据库，后面会添加相应的数据权限给当前用户。</p>
<pre><code class="language-java">@Service
public class TraceBatchesServiceImpl extends MPJBaseServiceImpl&lt;TraceBatchesMapper, TraceBatches&gt;
    implements ITraceBatchesService, ILuwuService {

  private final IAttachmentService attachmentService;

  @Value(&quot;${trace-batches.switch.extension-enable}&quot;)
  private Boolean extensionEnable;

  @Value(&quot;${trace-batches.switch.closed-enable}&quot;)
  private Boolean closedEnable;

  @Lazy
  public TraceBatchesServiceImpl(final IAttachmentService attachmentService) {
    super();
    this.attachmentService = attachmentService;
  }

  public Integer create(final TraceBatchesAddRequest request,
      final UserDTO userdto) throws SqlOtherException, DuplicatedTraceBatchesException {

    final TraceBatches traceBatches = generateTraceBatches(request, userdto);
    try {
      save(traceBatches);
    } catch (DuplicateKeyException e) {
      log.warn(&quot;saving traceBatches volatile unique constraint&quot;, e);
      if (Objects.requireNonNull(e.getMessage())
          .contains(Constants.UNIQUE_CONFLICT_ERROR_MESSAGE)) {
        throw new DuplicatedTraceBatchesException(&quot;duplicated creation with traceBatches&quot;, e,
            traceBatches);
      }
      throw new SqlOtherException(&quot;Saving traceBatches encounters &quot;
          + &quot;other sql exception&quot;, e);
    }

    final ItemRequest itemRequest = generateItemRequest(traceBatches.getId(),
        request.getProductId(), userdto);
    permission(itemRequest, userdto);

    return traceBatches.getId();
  }

  public TraceBatches generateTraceBatches(final TraceBatchesAddRequest request,
      final UserDTO userdto) {
    final TraceBatches traceBatches = new TraceBatches();
    // do some set things
    return traceBatches;
  }

  public ItemRequest generateItemRequest(final int traceBatchesId,
      final int productId,
      final UserDTO userdto) {
    final ItemRequest itemRequest = new ItemRequest();
    // do some set things
    return itemRequest;
  }
}
</code></pre>
<p>Service Test层逻辑</p>
<p>​   Base Service Test 通常建立一个基础类，让该类去添加通用注解，测试去继承该类去初始化对应的模拟对象。</p>
<pre><code class="language-java">import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

/**
 * base service test for enable Mockito annotations
 * to use @InjectMocks and @Mock annotation.
 */
@ExtendWith(MockitoExtension.class)
public class BaseServiceTest {
}
</code></pre>
<p>​   TraceBatch Service Test 首先通过@InjectMocks和@Mock去确定要测试对象并注入关联对象。</p>
<pre><code class="language-java">class TraceBatchesServiceImplTest extends BaseServiceTest {
  @InjectMocks
  private TraceBatchesServiceImpl traceBatchesServiceTest;
  @Mock
  private IAttachmentService attachmentService;
}
</code></pre>
<p>​   然后去创建测试方法去测试真实的create方法逻辑，此时发现要测试的create方法中用到了save方法，但是save方法不是TraceBatchesServiceImpl本身的方法，到这里我们知道要去模拟save这个方法了。查看源码找到这个save方法是IService接口内的默认方法。</p>
<pre><code class="language-java">public interface IService&lt;T&gt; {
  ...
  default boolean save(T entity) {
      return SqlHelper.retBool(getBaseMapper().insert(entity));
  }
  ...
}
</code></pre>
<p>​   去模拟save方法就是要对测试类中的部分方法做模拟，所以可以用spy的方式去实现。细心观察这里多加了一个<code>generateTraceBatches</code>方法的模拟，是为了保证真实的save方法中的参数和模拟的参数相一致。<strong>注意模拟save方法时传参一定要和真实的传参一致，如果参数是对象那么内部的set值也要完全一样，不然真实逻辑不会流转到模拟的方法上。</strong></p>
<pre><code class="language-java">  // 将traceBatchesServiceTest赋值给spy，是用spy去模拟部分方法
    final TraceBatchesServiceImpl spy = spy(traceBatchesServiceTest);
    // 调用真实的方法创建traceBatches对象
  final TraceBatches traceBatches = spy.generateTraceBatches(traceBatchesAddRequest, userDto);
  traceBatches.setId(ID);
  doReturn(traceBatches).when(spy).generateTraceBatches(traceBatchesAddRequest, userDto);
  doReturn(true).when(spy).save(traceBatches);
</code></pre>
<p>​   最后使用assert去判断create方法返回结果。</p>
<pre><code class="language-java">  Assertions.assertEquals(ID, (long) spy.create(traceBatchesAddRequest, userDto),&quot;test: result is equal&quot;);
  verify(spy, times(1)).create(traceBatchesAddRequest, userDto);
</code></pre>
<p>​   完整示例：</p>
<pre><code class="language-java">import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.lang.reflect.Field;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.dao.DuplicateKeyException;

/**
 * TraceBatchesService unit test.
 */
@SuppressWarnings({&quot;PMD.AtLeastOneConstructor&quot;,
    &quot;PMD.TooManyStaticImports&quot;, &quot;PMD.TooManyMethods&quot;})
class TraceBatchesServiceImplTest extends BaseServiceTest {

  private static final int ID = 1;
  private static final int PRODUCT_ID = 1;
  public static final String EXTENSION = &quot;extension&quot;;

  @InjectMocks
  private TraceBatchesServiceImpl traceBatchesServiceTest;

  @Mock
  private IAttachmentService attachmentService;

  private TraceBatchesAddRequest traceBatchesAddRequest;
  private UserDTO userDto;

  @BeforeEach
  void init() {
    traceBatchesServiceTest = new TraceBatchesServiceImpl(productMapper,
         markMapper, stepTempService, stepDetailService,
        attachmentService, iotInfoService, deviceService, warnPolicyService,
        executorLuwuService, excelUtils);

    traceBatchesAddRequest = new TraceBatchesAddRequest();
    traceBatchesAddRequest.setProductId(PRODUCT_ID);
    traceBatchesAddRequest.setProductNum((long) 10);
    traceBatchesAddRequest.setExtension(EXTENSION);
    traceBatchesAddRequest.setNote(&quot;5&quot;);
    traceBatchesAddRequest.setClosed(true);

    userDto = new UserDTO();
    userDto.setUsername(&quot;admin&quot;);
    userDto.setAppId(&quot;754&quot;);
  }

  void stubSave(final TraceBatchesServiceImpl spy) {
    final TraceBatches traceBatches =
        spy.generateTraceBatches(traceBatchesAddRequest, userDto);
    traceBatches.setId(ID);
    final ItemRequest itemRequest =
        spy.generateItemRequest(traceBatches.getId(), traceBatches.getProductId(), userDto);
    doReturn(traceBatches).when(spy).generateTraceBatches(traceBatchesAddRequest, userDto);
    doReturn(true).when(spy).save(traceBatches);
    doNothing().when(spy).permission(itemRequest, userDto);
  }

  void stubSaveThrow(final TraceBatchesServiceImpl spy, final String errorMsg) {
    final TraceBatches traceBatches = spy.generateTraceBatches(traceBatchesAddRequest, userDto);
    doReturn(traceBatches).when(spy).generateTraceBatches(traceBatchesAddRequest, userDto);
    doThrow(new DuplicateKeyException(errorMsg)).when(spy).save(traceBatches);
  }

  @Test
  void createTest() throws NoSuchFieldException, IllegalAccessException,
      SqlOtherException, DuplicatedTraceBatchesException {
    updateField(true, true);
    final TraceBatchesServiceImpl spy = spy(traceBatchesServiceTest);
    stubSave(spy);

    final int actual = spy.create(traceBatchesAddRequest, userDto);
    Assertions.assertEquals(ID, (long) actual, &quot;test: method result is equal&quot;);
    verify(spy, times(1))
        .create(traceBatchesAddRequest, userDto);
  }

  @Test
  void createThrowDuplicateTest()
      throws SqlOtherException, DuplicatedTraceBatchesException,
      NoSuchFieldException, IllegalAccessException {
    updateField(true, true);
    final TraceBatchesServiceImpl spy = spy(traceBatchesServiceTest);
    stubSaveThrow(spy, Constants.UNIQUE_CONFLICT_ERROR_MESSAGE);

    Assertions.assertThrows(DuplicatedTraceBatchesException.class,
        () -&gt; spy.create(traceBatchesAddRequest, userDto));
    verify(spy, times(1))
        .create(traceBatchesAddRequest, userDto);
  }

  @Test
  void createThrowSqlOtherTest()
      throws SqlOtherException, DuplicatedTraceBatchesException,
      NoSuchFieldException, IllegalAccessException {
    updateField(true, true);
    final TraceBatchesServiceImpl spy = spy(traceBatchesServiceTest);
    stubSaveThrow(spy, &quot;other exception sql&quot;);

    Assertions.assertThrows(SqlOtherException.class,
        () -&gt; spy.create(traceBatchesAddRequest, userDto));
    verify(spy, times(1))
        .create(traceBatchesAddRequest, userDto);
  }

  @Test
  void generateTraceBatchesForExtensionTrueTest()
      throws NoSuchFieldException, IllegalAccessException {
    updateField(true, true);

    final TraceBatches actual = traceBatchesServiceTest
        .generateTraceBatches(traceBatchesAddRequest, userDto);
    Assertions.assertEquals(EXTENSION, actual.getExtension(),
        &quot;test: extension result is equal&quot;);
  }

  @Test
  void generateTraceBatchesForExtensionFalseTest()
      throws NoSuchFieldException, IllegalAccessException {
    updateField(false, false);

    final TraceBatches actual = traceBatchesServiceTest
        .generateTraceBatches(traceBatchesAddRequest, userDto);
    Assertions.assertNotNull(actual.getExtension());
  }

  @Test
  void generateTraceBatchesForClosedTrueTest()
      throws NoSuchFieldException, IllegalAccessException {
    updateField(false, true);

    final TraceBatches actual = traceBatchesServiceTest
        .generateTraceBatches(traceBatchesAddRequest, userDto);
    Assertions.assertNotNull(actual.getClosed());
  }

  @Test
  void generateTraceBatchesForClosedFalseTest()
      throws NoSuchFieldException, IllegalAccessException {
    updateField(true, false);

    final TraceBatches actual = traceBatchesServiceTest
        .generateTraceBatches(traceBatchesAddRequest, userDto);
    Assertions.assertEquals(&quot;0&quot;, actual.getClosed(),
        &quot;test: closed result is equal&quot;);
  }

  @SuppressWarnings(&quot;PMD.AvoidAccessibilityAlteration&quot;)
  void updateField(final boolean extensionEnable, final boolean closedEnable)
      throws IllegalAccessException, NoSuchFieldException {
    final Field field = traceBatchesServiceTest.getClass().getDeclaredField(&quot;extensionEnable&quot;);
    field.setAccessible(true);
    field.set(traceBatchesServiceTest, extensionEnable);

    final Field closedField = traceBatchesServiceTest.getClass().getDeclaredField(&quot;closedEnable&quot;);
    closedField.setAccessible(true);
    closedField.set(traceBatchesServiceTest, closedEnable);
  }

}
</code></pre>
<h4 id="dao">DAO</h4>
<p>DAO的测试有多种方式，目前比较常用的有spring test集成h2以及spring test集成testcontainer，下面主要介绍一下这两种方式。</p>
<p>H2：h2的优点就是启动方式简单，速度快；缺点就是h2的部分语法和mysql不兼容，同时会在系统中存在两份初始化sql脚本，会导致两边修改不一致；</p>
<p>Testcontainer：优点是使用docker启动一个mysql实例，初始化脚步可以和系统的是同一份，保证了环境的一致性；缺点是开发者本地需要安装docker，并且CI中要使用docker in docker的模式，启动也比较复杂。</p>
<p>DAO中使用到的关键注解有：</p>
<ul>
<li>@Testcontainers</li>
<li>@SpringBootTest</li>
<li>@Container</li>
<li>@DynamicPropertySource</li>
<li>@BeforeEach</li>
<li>@AfterEach</li>
</ul>
<p>@Testcontainers 主要是用作测试中自动启动、停止容器的。测试容器会找到所有用Container标注的字段，并在容器的生命周期内调用它们的方法。<strong>注：声明为静态字段的容器将在测试方法之间共享，它们只会在任何测试方法执行之前启动一次，并在最后一个测试方法执行之后停止。声明为实例字段的容器将为每个测试方法启动和停止</strong>。
@Container 注释与Testcontainers注释一起使用，以标记容器由testcontainer去管理。
@DynamicPropertySource 用于集成测试的方法级注释，这些测试需要将具有动态值的属性添加到环境的PropertySource中。</p>
<h4 id="reference">Reference</h4>
<p>[https://doczhcn.gitbook.io/junit5/index/index-2/annotations] (Junit 5官方文档中文版)</p>
<p>[https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html] (Mockito 官方文档)</p>
<p>[https://spring.io/guides/gs/testing-web/] (Spring Testing the Web Layer)</p>
<p>[https://medium.com/backend-habit/integrate-junit-and-mockito-unit-testing-for-controller-layer-91bb4099c2a5] (Web Layer)</p>
<p>[https://www.cnblogs.com/NeverCtrl-C/p/8996564.html] (Web Layer)</p>
<p>[https://baomidou.com/pages/226c21/] (Mybatis-Plus)</p>
<p>[https://github.com/binkley/modern-java-practices] (modern java practices)</p>
<p>[https://www.testcontainers.org/] (Testcontainers 官网)</p>
<p>[https://rieckpil.de/howto-write-spring-boot-integration-tests-with-a-real-database/] (Testcontainers mysql)</p>
<h3 id="git">Git</h3>
<h3 id="docker">Docker</h3>
<p><img src="img/docker-img.png" alt="Screenshot" style="zoom:50%;" /></p>
<h3 id="k8s">K8S</h3>
<h2 id="_3">问题记录</h2>
<h3 id="cicd">CI/CD</h3>
<h4 id="dinddocker-in-docker">DIND（docker in docker）</h4>
<p>描述：编写集成测试，需要用到spicedb，通过代码的dockertest启动一个docker spicedb容器，通过grpc连接spicedb容器向其中添加数据做测试，gitlab-ci的test报错历史</p>
<blockquote>
<p>Could not start resource: : dial unix /var/run/docker.sock: connect: no such file or directory</p>
</blockquote>
<p>原因：gitlab-ci中的镜象是golang，所以启动后runner-test内部只有golang的环境，并且宿主机启动runner的配置中也没有挂载docker.sock，导致内部无法访问外部的docker
修改：将gitlab-ci中的镜象改成docker镜象，同时添加service: docker-dind</p>
<blockquote>
<p>/bin/bash: line 115: docker: command not found</p>
</blockquote>
<p>原因：把test-coverage中的image删掉了
修改：把test-coverage中的image加上，并且使用的是docker:19.03.13</p>
<blockquote>
<p>ERROR: error during connect: Get http://docker:2375/v1.40/info: dial tcp: lookup docker on 100.100.2.136:53: no such host</p>
</blockquote>
<p>原因：由于没有给docker配置相应的docker主机
修改：给docker添加相应的主机，在service中添加：
services 
     name: docker:19.03.12-dind 
     alias: dockerhost
在gitlab-ci中添加：
variables:
     DOCKER_HOST: tcp://dockerhost:2375/</p>
<blockquote>
<p>ERROR: Cannot connect to the Docker daemon at tcp://dockerhost:2375/. Is the docker daemon running?</p>
</blockquote>
<p>原因：由于我们使用的是docker官方的docker：dind镜像，该镜像在18.09+下做了变化，主要是TLS证书认证这块。gitlab没有适配这个变化
修改：gitlab-ci.yml文件里面添加一下配置：
variables:
     DOCKER_DRIVER: overlay2
     DOCKER_TLS_CERTDIR: ""</p>
<blockquote>
<p>/bin/sh: eval: line 127: go: not found</p>
</blockquote>
<p>原因：命令行中去下载并安装golang，安装后没有生效，这是由于通过docker启动的这个runner-test是一个alpine环境，缺少很多基础依赖
修改：在gitlab-ci.yml中添加脚本安装必需的依赖，脚本命令：
    apk update &amp;&amp; apk add -f --virtual build-essential
    apk add make
    apk add gcc
    apk add musl-dev</p>
<blockquote>
<p>uname -c uname: unrecognized option: c</p>
</blockquote>
<p>原因：中间通过命令查看runner-test的系统信息，命令不对
修改：使用uname -a，系统信息：Linux runner-vxe1ctwm-project-1555-concurrent-0 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 Linux</p>
<blockquote>
<p>cgo: exec gcc: exec: "gcc": executable file not found in $PATH</p>
</blockquote>
<p>原因：缺少gcc依赖
修改：添加命令apk add gcc下载依赖</p>
<blockquote>
<p>Do you want to continue [Y/n]?</p>
</blockquote>
<p>原因：安装过程有需要确认的步骤
解决：在 apk add 后加 -f强制执行，不需确认</p>
<blockquote>
<p>/bin/sh: eval: line 133: make: not found</p>
</blockquote>
<p>原因：缺少make的依赖
解决：添加命令apk add make下载依赖</p>
<blockquote>
<p>_cgo_export.c:3:10: fatal error: stdlib.h: No such file or directory 3 | #include <stdlib.h></p>
</blockquote>
<p>原因：缺少stdlib.h的包
解决：添加以下命令：
     sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories
     apk update &amp;&amp; apk add -f --virtual build-essential</p>
<blockquote>
<p>panic: test timed out after 10m0s</p>
</blockquote>
<p>原因：由于没有拉取spicedb的镜象，导致启动spicedb超时
解决：添加以下命令：
      docker pull jauderho/spicedb:v1.1.0</p>
<blockquote>
<p>filter_test.go:340: rpc error: code = Unavailable desc = connection error: desc = "transport: Error while dialing dial tcp 127.0.0.1:32768: connect: connection refused" Error:  Condition never satisfied Test:  TestAuthzed_Filter Messages: could not start test server</p>
</blockquote>
<p>原因：使用grpc连接spicedb发现连接被拒绝，是因为代码中用的是loaclhost，而runner-test中的docker主机是我们开始配置的dockerhost
解决：修改代码中的locahost，改为dockerhost，测试通过</p>
<p>总结：使用gitlab-ci的docker in docker要注意内部docker的环境依赖问题以及主机的配置问题</p>
<p>golang-ci.yaml 附件：</p>
<pre><code class="language-yaml"># image: golang:1.16.12-alpine3.14
stages: # List of stages for jobs, and their order of execution
  - pull-code
  - lint-check
  - test
  - build
  - deploy

#pull-code-job:
#  stage: pull-code
#  before_script:
#    - echo &quot;pull code start&quot;
#  script:
#    - echo &quot;pulling code&quot;
#  after_script:
#    - echo &quot;pull code end&quot;
services:
  - name: docker:19.03.12-dind
    alias: dockerhost

variables:
  DOCKER_HOST: tcp://dockerhost:2375/
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: &quot;&quot;
  DOCKER_AUTH_CONFIG: https://hub-mirror.c.163.com

lint-check-job:
  stage: lint-check
  timeout: 300 seconds
    # 仅dev分支和test分支进行lint检查
    #  image:
    #    name: golangci/golangci-lint:v1.30.0-alpine
    #    entrypoint: [ &quot;&quot; ]entrypoint
    #  only:
    #    refs:
    #      - master
  # 修改特定目录时触发此job
  #    changes:
  #      - /
  tags:
    - bj-shell
  before_script:
    - echo &quot;lint tool check source code start&quot;
  script:
    - echo &quot;lint tool checking&quot;
    - go version
    - make lint
  after_script:
    - echo &quot;lint tool check source code end&quot;
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json

build-job: # This job runs in the build stage, which runs first.
  stage: build
  before_script:
    - echo &quot;Compile the code start&quot;
  script:
    - echo &quot;compling&quot;
  after_script:
    - echo &quot;Compile complete.&quot;

test-coverage: # This job runs in the test stage.
  stage: test    # It only starts when the job in the build stage completes successfully.
  image:
    name: docker:19.03.12
  tags:
    - bj-docker
  timeout: 3600 seconds
  before_script:
    - docker info
  script:
    - echo &quot;prepare golang environment...&quot;
    - wget https://studygolang.com/dl/golang/go1.16.7.linux-amd64.tar.gz &amp;&amp; tar -C /usr/local -xzf go1.16.7.linux-amd64.tar.gz
    - mkdir /lib64 &amp;&amp; ln -s /lib/ld-musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2
    - export PATH=$PATH:/usr/local/go/bin
    - export GOPROXY=https://goproxy.cn,direct
    - go env -w GOPROXY=https://goproxy.cn
    - sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories
    - apk update &amp;&amp; apk add -f --virtual build-essential
    - apk add make
    - apk add gcc
    - apk add musl-dev
    - docker pull jauderho/spicedb:v1.1.0
    - echo &quot;Running unit tests...&quot;
    - export DOCKER_ALIAS=dockerhost
    - make cover

#deploy-dev-job:      # This job runs in the deploy stage.
##  needs:
#  stage: deploy  # It only runs when *both* jobs in the test stage complete successfully.
#  only:
#    - dev
#  script:
#    - echo &quot;Deploying application on dev...&quot;
#    - echo &quot;Application successfully deployed.&quot;
#deploy-test-job:      # This job runs in the deploy stage.
#  stage: deploy  # It only runs when *both* jobs in the test stage complete successfully.
#  only:
#    - test
#  script:
#    - echo &quot;Deploying application on test...&quot;
#    - echo &quot;Application successfully deployed.&quot;
#deploy-pro-job:      # This job runs in the deploy stage.
#  stage: deploy  # It only runs when *both* jobs in the test stage complete successfully.
#  only:
#    - main
#  script:
#    - echo &quot;Deploying application on prod...&quot;
#    - echo &quot;Application successfully deployed.&quot;
</code></pre>
<h3 id="_4">其他</h3>
<h4 id="mybatis-plus-in-condition">mybatis-plus in condition</h4>
<p>问题描述：在mybatis-plus中使用in条件过滤数据，发现in条件失效</p>
<p>编码及日志：queryWrapper.in("id", queryResult.getList().isEmpty() ? "" : queryResult.getList());</p>
<pre><code class="language-java">2022-04-09 17:46:31 DEBUG c.xxxx.mapper.auto.SysMenuMapper.selectList &gt;&gt;&gt; ==&gt;  Preparing: SELECT id,name,definition,i18n,type,url,parent_id,desc_no FROM sys_menu WHERE (type = ? AND id IN (?))
2022-04-09 17:46:31 DEBUG c.xxxx.mapper.auto.SysMenuMapper.selectList &gt;&gt;&gt; ==&gt; Parameters: PLAT(String), [11, 12, 13, 14](ArrayList)
2022-04-09 17:46:31 DEBUG c.xxxx.mapper.auto.SysMenuMapper.selectList &gt;&gt;&gt; &lt;==      Total: 0
</code></pre>
<ol>
<li>查看QueryWrapper的源码，对于in方法的传参支持value...和Collection，并且我这里的参数类型是List，属于Collection集合。带着问题进行了debug，查看queryWrapper的内部拼接，如下图：</li>
</ol>
<p><img src="img/image-1.png" alt="Screenshot" style="zoom:50%;" /></p>
<p>参数在arg2中多嵌套了一层，这导致in内参数不能对应，所以无法查到数据。</p>
<ol>
<li>
<p>后面查看了一些网上的资料，由于in方法提供了两种方式，如果参数不明确，会导致参数类型无法识别，因为这里我使用的是一个三元表达式。</p>
</li>
<li>
<p>后面修改成：queryWrapper.in("id", queryResult.getList()); 再次debug，查看queryWrapper的内部拼接，如下图：</p>
</li>
</ol>
<p><img src="img/image-2.png" alt="Screenshot" style="zoom:50%;" /></p>
<p>参数位置变正常，数据也能查询出来。</p>
<p>日志：</p>
<pre><code class="language-java">2022-04-09 18:09:21 DEBUG c.xxxx.mapper.auto.SysMenuMapper.selectList &gt;&gt;&gt; ==&gt;  Preparing: SELECT id,name,definition,i18n,type,url,parent_id,desc_no FROM sys_menu WHERE (type = ? AND id IN (?,?,?,?))
2022-04-09 18:09:21 DEBUG c.xxxx.mapper.auto.SysMenuMapper.selectList &gt;&gt;&gt; ==&gt; Parameters: PLAT(String), 11(String), 12(String), 13(String), 14(String)
2022-04-09 18:09:21 DEBUG c.xxxx.mapper.auto.SysMenuMapper.selectList &gt;&gt;&gt; &lt;==      Total: 4
</code></pre>
<ol>
<li>疑惑</li>
</ol>
<p>官网中in方法的介绍中提到：如果集合为 empty 则不会进行 sql 拼接，</p>
<p>不太明白这里的sql拼接是指in的sql拼接还是里面的内容不做拼接，测试的实际情况是还会有in条件，in条件后面的括号中没有任何值。个人觉得这里是否不太妥当，如果不去手动判断集合空做特殊处理，这里是会报错的。</p>
<ol>
<li>总结</li>
</ol>
<p>多思考多看源码多实践。</p>
<h4 id="spring-resttemplateurlencode">Spring-RestTemplate之urlencode参数解析异常</h4>
<p>问题：在开发中A系统通过<code>restTemplate</code>去调用外部的B系统，分页或者列表查询时传参有中文会出现查询不到数据的情况，但是通过postman或者curl却能正常查到数据，开始怀疑是中文编码的问题。</p>
<p>调用外部系统代码：</p>
<pre><code class="language-java">  @Test
  void restTemplateTest() {
    String url = &quot;http://host:port/api/v1/apps/{appId}/roles&quot; +
        &quot;?name=大&amp;pageSize=10&amp;pageNum=1&quot;;
    UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(url);

    final HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    headers.set(LuwuConstants.COLUMN_USER_ID, &quot;c85aa18737e84db9a813a542c270c2a1&quot;);
    headers.set(LuwuConstants.COLUMN_USER_ID, &quot;391f837e8a10491b92da5dac7ff17673&quot;);
    HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(headers);

    RestTemplate restTemplate = new RestTemplate();
    final ResponseEntity&lt;String&gt; result = restTemplate.exchange(uriBuilder.toUriString(),
        HttpMethod.GET, entity, String.class);
    System.out.println(result.getBody());
  }
</code></pre>
<p>系统日志：</p>
<pre><code class="language-shell">21:11:41.008 [Test worker] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://host:port/api/v1/apps/3450749dcc9244368fbf1ee967707145/roles?name=%25E5%25A4%25A7&amp;pageSize=10&amp;pageNum=1
21:11:41.016 [Test worker] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]
21:11:41.131 [Test worker] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK
21:11:41.134 [Test worker] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json;charset=utf-8&quot;
{&quot;code&quot;:&quot;200&quot;,&quot;message&quot;:&quot;&quot;,&quot;data&quot;:{&quot;list&quot;:[],&quot;pagination&quot;:{&quot;total&quot;:0,&quot;pageSize&quot;:10,&quot;pageNum&quot;:1}}}
BUILD SUCCESSFUL in 5s
5 actionable tasks: 2 executed, 3 up-to-date
9:11:41 下午: Task execution finished ':test --tests &quot;com.xxxx.CubeApplicationTest.restTemplateTest&quot;'.
</code></pre>
<p>通过浏览器发送：</p>
<p><img src="img/image-3.png" alt="Screenshot" style="zoom:50%;" /></p>
<p>仔细对比上下条件中的中文编码值，浏览器发送的编码值是：<code>%E5%A4%A7</code>；而通过<code>restTemplate</code>发送的编码是：<code>%25E5%25A4%25A7</code>。原来<code>restTemplate</code>发送时会将请求参数中<code>%</code>编码为<code>%25</code>，浏览器传进来时已经做了编码，但是通过<code>restTemplate</code>发送时又编码了一道，导致参数已经不是原来的参数了，所以请求数据查询不出来。</p>
<p>查看源码发现，如果<code>restTemplate</code>的URI传入的是string类型时，<code>restTemplate</code>会将URI中的参数进行转码，如果传入是URI对象时，会使用URI中的参数，此时的参数已被URI转码了。</p>
<p>修改后：</p>
<pre><code class="language-java">  @Test
  void restTemplateTest() {
    String url = &quot;http://host:port/api/v1/apps/{appId}/roles&quot; +
        &quot;?name=大&amp;pageSize=10&amp;pageNum=1&quot;;
    UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(url);

    final HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    headers.set(LuwuConstants.COLUMN_USER_ID, &quot;c85aa18737e84db9a813a542c270c2a1&quot;);
    headers.set(LuwuConstants.COLUMN_USER_ID, &quot;391f837e8a10491b92da5dac7ff17673&quot;);
    HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(headers);
    RestTemplate restTemplate = new RestTemplate();
    final ResponseEntity&lt;String&gt; result = restTemplate.exchange(uriBuilder.build().toUri(),
        HttpMethod.GET, entity, String.class);
    System.out.println(result.getBody());
  }
</code></pre>
<p>系统日志：</p>
<pre><code class="language-shell">21:14:20.942 [Test worker] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://host:port/api/v1/apps/3450749dcc9244368fbf1ee967707145/roles?name=大&amp;pageSize=10&amp;pageNum=1
21:14:20.956 [Test worker] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]
21:14:21.070 [Test worker] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK
21:14:21.077 [Test worker] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json;charset=utf-8&quot;
{&quot;code&quot;:&quot;200&quot;,&quot;message&quot;:&quot;&quot;,&quot;data&quot;:{&quot;list&quot;:[{&quot;id&quot;:&quot;404f97054e344db4a56979a3fbde781a&quot;,&quot;name&quot;:&quot;3450749dcc9244368fbf1ee967707145|大小角色&quot;,&quot;displayName&quot;:&quot;大小角色&quot;,&quot;createdAt&quot;:&quot;2022-04-15T08:12:42.102Z&quot;}],&quot;pagination&quot;:{&quot;total&quot;:1,&quot;pageSize&quot;:10,&quot;pageNum&quot;:1}}}
BUILD SUCCESSFUL in 5s
5 actionable tasks: 2 executed, 3 up-to-date
9:14:21 下午: Task execution finished ':test --tests &quot;com.xxxx.CubeApplicationTest.restTemplateTest&quot;'.
</code></pre>
<p>数据查询正常！</p>
<p>总结：当使用<code>RestTemplate</code>发起请求时，url参数中带有中文或需要编码时，应该使用URI对象作为exchange方法的传参，而不是字符串。</p>
<p>参考文档：</p>
<p>[https://cloud.tencent.com/developer/article/1407555]</p>
<h4 id="spring-logback-additivity">Spring-logback additivity</h4>
<p>背景：业务需求要通过ELK实现一个审计的功能，可对接任何项目的审计部分。项目的审计部分实现需要用到拦截器和logback的技术，主要的一个实现方式就是通过拦截器拦截每次的一个请求，将请求的操作信息通过日志写入到指定的文件中，供ELK去采集。</p>
<p>问题：配置了logback-spring.xml文件，内部添加一个appender，扫描指定包下的TRACE级别的日志输出到log文件中，但是该包下也有一些INFO级别的日志，发现INFO级别的日志丢失，不再打印到控制台。</p>
<p>logback-spring.xml配置如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot;/&gt;

    &lt;appender name=&quot;audit_log&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;log/audit_log.log.%d{yyyy-MM-dd}&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder charset=&quot;UTF-8&quot;&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg日志消息,%n是换行符--&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss,CTT} %-5level 15210 %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
        &lt;!--这里设置日志级别为trace,只输出trace日志--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;level&gt;TRACE&lt;/level&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;com.xxxxxx.xxxx.interceptor&quot; level=&quot;TRACE&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;audit_log&quot; /&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre>
<p>开始以为是filter中的DENY丢弃了其他的级别的日志，改为NEUTRAL继续向后过滤，发现和预想的不一样，INFO级别的日志还是打印不出来。网上查了一些原因，很多都提到了additivity这个选项。后面查看官方文档，查了一下additivity的一个原理，终于理解了出现这种现象的原因。</p>
<p>主要原因：additivity默认是true，表示开启。true的含义是当前这个包audit的logger会叠加通过root的logger，也就是说日志不仅会在audit下输出也会同时在root下输出，而且audit的日志级别不受root的日志级别控制，就算日志级别比root的低也会输出。false的含义就是日志仅会在audit的logger下输出，audit对应包下的日志信息将不再会叠加输出到root下。所以因为这里additivity使用的是false，因此这个包下的其他日志将不会再打印到主控制台了。</p>
<p>这里有两种来自网络的比较形象的图：</p>
<p><img src="img/logback-additivity-1.png" alt="Screenshot" style="zoom:50%;" /></p>
<p>解决方式：知道了原因以及additivity的原理后，对应的解决方式也就知道了，这里一共有两种比较方便的解决方式，方式一是将包的范围缩小，可以指定到对应的类，这样audit的范围就变小了也就不会再影响到其他的日志信息；方式二是将additivity改为true，这样audit内部的其他日志也会输出到主控制台，但是有一个缺点就是audit中的日志也会输出到主控制台，相同的日志会出现两份。个人建议使用第一种方式。</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme_extra.js" defer></script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>

<!--
MkDocs version : 1.2.3
Build Date UTC : 2022-06-28 04:35:04.888209+00:00
-->
